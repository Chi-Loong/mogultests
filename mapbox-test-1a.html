<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Add a 3D model</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
<link href="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.css" rel="stylesheet">
<script src="https://api.mapbox.com/mapbox-gl-js/v2.7.0/mapbox-gl.js"></script>
<style>
body { margin: 0; padding: 0; }
#map { position: absolute; top: 0; bottom: 0; width: 100%; }
</style>
</head>
<body>
<script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
<div id="map"></div>
<script>
	// TO MAKE THE MAP APPEAR YOU MUST
	// ADD YOUR ACCESS TOKEN FROM
	// https://account.mapbox.com
	mapboxgl.accessToken = 'pk.eyJ1IjoicGFwZXJkIiwiYSI6ImNrNnE5YTNkcDAwNzQzZW1ndTcwcTd3MWkifQ.cS6iY5XX9nxLYUpcXkdB-w';
const map = new mapboxgl.Map({
	container: 'map',
	style: 'mapbox://styles/mapbox/light-v10',
	zoom: 18,
	center: [103.8403333, 1.3158396],
	pitch: 60,
	antialias: true // create the gl context with MSAA antialiasing, so custom layers are antialiased
});
 
// parameters to ensure the model is georeferenced correctly on the map
const modelOrigin = [103.8403333, 1.3158396];
const modelAltitude = 0;
const modelRotate = [Math.PI / 2, 0, 0];
 
const modelAsMercatorCoordinate = mapboxgl.MercatorCoordinate.fromLngLat(
	modelOrigin,
	modelAltitude
);
 
// transformation parameters to position, rotate and scale the 3D model onto the map
const modelTransform = {
	translateX: modelAsMercatorCoordinate.x,
	translateY: modelAsMercatorCoordinate.y,
	translateZ: modelAsMercatorCoordinate.z,
	rotateX: modelRotate[0],
	rotateY: modelRotate[1],
	rotateZ: modelRotate[2],
	/* Since the 3D model is in real world meters, a scale transform needs to be
	* applied since the CustomLayerInterface expects units in MercatorCoordinates.
	*/
	scale: modelAsMercatorCoordinate.meterInMercatorCoordinateUnits() * 1
};
 
const THREE = window.THREE;
 
// configuration of the custom layer for a 3D model per the CustomLayerInterface
const customLayer = {
	id: '3d-model',
	type: 'custom',
	renderingMode: '3d',
	onAdd: function (map, gl) {
	this.camera = new THREE.Camera();
	this.scene = new THREE.Scene();

	// create two three.js lights to illuminate the model
	const directionalLight = new THREE.DirectionalLight(0xffffff);
	directionalLight.position.set(0, -70, 100).normalize();
	directionalLight.castShadow = true; // default false
	this.scene.add(directionalLight);

	const directionalLight2 = new THREE.DirectionalLight(0xffffff);
	directionalLight2.position.set(0, 70, 100).normalize();
	directionalLight2.castShadow = true; // default false
	this.scene.add(directionalLight2);

	directionalLight2.shadow.mapSize.width = 512; // default
	directionalLight2.shadow.mapSize.height = 512; // default
	directionalLight2.shadow.camera.near = 0.5; // default
	directionalLight2.shadow.camera.far = 500; // default

	// use the three.js GLTF loader to add the 3D model to the three.js scene
	const loader = new THREE.GLTFLoader();
	loader.load(
	'model/enchante.glb',
	(gltf) => {
	this.scene.add(gltf.scene);
	}
	);
	this.map = map;

	console.log(this.scene);
	 
	// use the Mapbox GL JS map canvas for three.js
	this.renderer = new THREE.WebGLRenderer({
		canvas: map.getCanvas(),
		context: gl,
		antialias: true
	});
	this.renderer.shadowMap.enabled = true;
	this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
	 
	this.renderer.autoClear = false;
	},
	render: function (gl, matrix) {
	const rotationX = new THREE.Matrix4().makeRotationAxis(
	new THREE.Vector3(1, 0, 0),
	modelTransform.rotateX
	);
	const rotationY = new THREE.Matrix4().makeRotationAxis(
	new THREE.Vector3(0, 1, 0),
	modelTransform.rotateY
	);
	const rotationZ = new THREE.Matrix4().makeRotationAxis(
	new THREE.Vector3(0, 0, 1),
	modelTransform.rotateZ
	);
	 
	const m = new THREE.Matrix4().fromArray(matrix);
	const l = new THREE.Matrix4()
	.makeTranslation(
	modelTransform.translateX,
	modelTransform.translateY,
	modelTransform.translateZ
	)
	.scale(
	new THREE.Vector3(
	modelTransform.scale,
	-modelTransform.scale,
	modelTransform.scale
	)
	)
	.multiply(rotationX)
	.multiply(rotationY)
	.multiply(rotationZ);
	 
	this.camera.projectionMatrix = m.multiply(l);
	this.renderer.resetState();
	this.renderer.render(this.scene, this.camera);
	this.map.triggerRepaint();
	}
};
 
map.on('style.load', () => {
	map.addLayer(customLayer, 'waterway-label');
});
</script>
 
</body>
</html>